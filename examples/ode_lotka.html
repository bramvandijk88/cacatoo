<html>
<script src="../dist/cacatoo.js"></script>                 <!-- Include cacatoo library (compiled with rollup) -->
<script src="../lib/all.js"></script>                      <!-- Include other libraries (concattenated in 1 file) -->
<script src="../lib/odex.js"></script>                      <!-- Include other libraries (concattenated in 1 file) -->
<link rel="stylesheet" href="../style/cacatoo.css">        <!-- Set style sheet -->

<script>
/*-----------------------Start user-defined code ---------------------*/

let model;

function setup()
{

    let config = {
            title: "ODEs in gridpoints",
            description: "Lotka-volterra systems coupled by (stochastic) diffusion",
            maxtime: 10000,
            fastmode: false,             
            ncol : 64,            
            nrow : 64,		            // dimensions of the grid to build
            wrap : [true, true],       // Wrap boundary [COLS, ROWS]   
            scale : 3				    // scale of the grid (nxn pixels per CA cell
                   // colourRamp extrapolates a spectrum of colours between the first and second RGB values
    }

    model = new Model(config)

    model.makeGrid("lotka"); 
    model.lotka.colourRamp('density',[0,0,0],[240,200,0],100)           // Will contain the ODEs, and show the abundance of PREDATORS
    model.makeGrid("prey")
    model.prey.colourRamp('density',[0,0,0],[148, 0, 211],100)          // Will be empty, but the grid will show the abundance of PREY


    // Define a basic Lotka Volterra ODE system
    // dx/dt = a x - b x y
    // dy/dt = c x y - d y
    let LotkaVolterra = function(a, b, c, d) { return function(x, y) {
        return [
            a * y[0] - b * y[0] * y[1],         // y[0] is the prey which replicates with rate a, and gets consumed by the predator with rate b
            c * y[0] * y[1] - d * y[1]          // y[1] is the predator which consumes prey with rate c, dies naturally with rate d
        ]}}

    // Set initial state and parameters
    let init_state = [0,0]          // y[0],y[1]
    let pars = [1.5,0.5,0.5,0.5]    // a,b,c,d
    
    // Attaches an ODE to all gridpoints with initial state = [0,0]. 
    // By default, all ODEs are stored in an array in the grid point, but...
    // If you want to access it by name, you can give a name as the final variable (here lotka)
    model.lotka.attachODE(LotkaVolterra,init_state,pars,"lotka"); 

    // Initialise the left 3 cols with predators and prey by setting the state via the named ODE 'lotka'
    model.lotka.grid[model.lotka.nc/2][model.lotka.nr/2].lotka.state = [10,10]
    
    // The nextState function has 3 steps: 1) ODE integration, 2) Diffusion, 3) Update what is displayed on the grid
    model.lotka.nextState = function(i,j)       // Define the next-state function. 
    {           
        // 1) ODE integration
        this.grid[i][j].lotka.solve_timestep(0.1)

        // 2.a) Diffusion of prey
        neigh = model.lotka.randomMoore8(this,i,j)          // Diffuse to random grid point to give the system a bit of noise (alternatively, you can diffuse to all)
        neigh_prey = neigh.lotka.state[0]
        this.grid[i][j].lotka.state[0] += neigh_prey/50
        neigh.lotka.state[0] -= neigh_prey/50
        
        // 2.b) Diffusion of predators
        neigh = model.lotka.randomMoore8(this,i,j)
        neigh_pred = neigh.lotka.state[1]
        this.grid[i][j].lotka.state[1] += neigh_pred/50
        neigh.lotka.state[1] -= neigh_pred/50
       
        // 3) Update how this GP is displayed
        let prey = Math.max(0,this.grid[i][j].lotka.state[0])       // Amount of prey (continuous variable)
        let pred = Math.max(0,this.grid[i][j].lotka.state[1])       // Amount of pred (continuous variable)
        this.grid[i][j].density = Math.min(Math.floor(pred*15),99)
        model.prey.grid[i][j].density = Math.min(Math.floor(prey*30),99)        
    }

    
    model.lotka.update = function()
    {
        this.asynchronous()                              // Asynchronous updating due to local diffusion... can be better
        //this.solve_odes(delta_t=0.1)                    //
        let sumpred = 0
        let sumprey = 0
        let midpred = 0
        let midprey = 0

        for(let i=0;i<this.nc;i++)         // i are columns
            for(let j=0;j<this.nr;j++)     // j are rows
            {     
                sumprey += this.grid[i][j].lotka.state[0]
                sumpred += this.grid[i][j].lotka.state[1]                
                if(i==this.nc/2 && j==this.nr/2) midprey = this.grid[i][j].lotka.state[0]
                if(i==this.nc/2 && j==this.nr/2) midpred = this.grid[i][j].lotka.state[1]
            }
            //sumpred/=this.nc*this.nr
            //sumprey/=this.nc*this.nr
        this.plotArray(["Predators", "Preys"], 
                        [sumpred,sumprey],
                        ["gold","#FF00AA"],
                        "Total predator/prey abundance")
        this.plotArray(["Predators", "Preys"], 
                    [midpred,midprey],
                    ["gold","#FF00AA"],
                    "ODE states in central grid point")

    }

    model.prey.nextState = function(i,j){}              // Normally needs a next-state function, but I'm using the other one to update the (visual) state of this grid
    model.prey.update = function() {}                   // Empty update function, same reason


    model.start()
	
	
}


/*-------------------------End user-defined code ---------------------*/

</script>



<body onload="setup()">
    <div class="header" id="header"></div>
    <div class="content" id="canvas_holder">  </div>
    <div class="content" id="graph_holder"> </div>
    <div class="footer" id="footer"></div>
</body>
</html>