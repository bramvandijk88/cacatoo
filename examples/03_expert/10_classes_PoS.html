<!-- 

    EXAMPLE FILE PoS: Pearls-on-a-string genomes with mutations

    If your models get increasingly complex, you may want to define your own classes. You can 
    either do this in a seperate file, or (as shown here) define the classes at the bottom of 
    your code. In this example, two classes (genomes and the genes within) are defined. 

    Genomes are ordered lists of genes. Genes have a type (essential, nonessential) and
    a function (function 1, function 2, etc.). The fitness of a genome is 1 by default,
    but if an essential gene is missing, fitness is 0. For each non-essential gene function
    the genome can perform, 0.1 is added to the fitness, making the maximum fitness 2.0.    

-->
<html>
<script src="../../dist/cacatoo.js"></script>                 <!-- Include cacatoo library (compiled with rollup) -->
<script src="../../lib/all.js"></script>                      <!-- Include other libraries (concattenated in 1 file) -->
<script src="../../lib/odex.js"></script>                      <!-- Include other libraries (concattenated in 1 file) -->
<link rel="stylesheet" href="../../style/cacatoo.css">        <!-- Set style sheet -->

<script>
/*-----------------------Start user-defined code ---------------------*/

let sim;

let init_es = 10                    // es = essential
let init_ne = 10

let death_rate = 0.02
let gene_deletion_rate = 0.01
let gene_duplication_rate = 0.01
let gene_tandem_deletion = 0.01
let gene_tandem_duplication = 0.01


function cacatoo()
{

    let config = {
            title: "TEs",
            description: "",
            maxtime: 20,
            fastmode: false,             // If possible, fast-mode will update the sim with more than 60 FPS. 
                                        // Note: fastmode is only useful/recommended if the sim can readily run 
                                        // at 60FPS without fast-mode, and may actually reduce the reported FPS
                                        // Nevertheless, the final state of the grid is reaches sooner in real time. 
            ncol : 50,            
            nrow : 50,		            // dimensions of the grid to build
            wrap : [true, true],       // Wrap boundary [COLS, ROWS]   
            scale : 5,				    // scale of the grid (nxn pixels per grid cell)
            graph_interval: 10,
            graph_update: 20,
            statecolours: {alive:{1:'blue'}}   // The background state '0' is never drawn
    }

    sim = new Simulation(config)

    sim.makeGridmodel("cells");
    sim.cells.colourViridis("genomesize", 100)
    sim.createDisplay("cells","genomesize")    
    sim.createDisplay("cells","eDNA")    

    sim.cells.initialise = function()
    {
        sim.initialGrid(sim.cells,"alive",0,1.0)
        sim.initialGrid(sim.cells,"genomesize",undefined,1.0)
        for(let i=0; i<sim.cells.nc; i++) for(let j=0;j<sim.cells.nr;j++)
        {
            // if(sim.cells.rng.genrand_real1() < 0.999)
            if(i==sim.cells.nc/2 && j==sim.cells.nr/2)
            { 
                sim.cells.grid[i][j].alive = 1
                sim.cells.grid[i][j].genome = new Genome()
                sim.cells.grid[i][j].genome.initialise(init_es,init_ne,10,1)
                sim.cells.grid[i][j].genomesize = sim.cells.grid[i][j].genome.chromosome.length             // A copy of the genome size is also stored within the grid point itself, so we can visualise it on the grid
                sim.cells.grid[i][j].fitness = sim.cells.grid[i][j].genome.fitness                          // A copy of the genomes' fitness is stored within the grid point itself, so we can use it for the "rouletteWheel" function
            }
        }
    }

    sim.cells.initialise()  // Initialise for the first time (otherwise used for "RESET" button)
    
        
    let birth_rate = 0.85
                
    sim.cells.nextState = function(i,j)       // Define the next-state function. This example is stochastic growth in a petri dish
    {           
        if(this.grid[i][j].alive == 0)
        {                   
            let neighbour = this.randomMoore8(this,i,j)              // In the Moore8 neighbourhood of this grid count # of 1's for the 'alive' property        
            let neighbours = this.getMoore8(this,i,j,1,'alive')
            
            if(neighbours.length > 0) 
            {   
                this.rouletteWheel(neighbours,'fitness',10.1)
                // console.log(neighbours)
            }
            if (neighbour.alive > 0 && sim.rng.genrand_real1() < neighbour.genome.fitness*0.1)                        
            {
                this.grid[i][j].alive = neighbour.alive
                this.grid[i][j].genome = neighbour.genome.copy(mutate=true)
                this.grid[i][j].genomesize = neighbour.genome.chromosome.length

            }
        } 
        else if(sim.rng.genrand_real1() < death_rate)
        {
            this.grid[i][j].alive = 0 
            this.grid[i][j].genomesize = undefined           
        }
    }

    
    sim.cells.update = function()
    {
        this.synchronous()         // Applied as many times as it can in 1/60th of a second
        this.plotPopsizes('alive',[1]) 

       let num_alive = 0, gsizes=0, hks = 0, nes = 0, non = 0, tra = 0, fitnesses = 0
       for(let i=0; i<sim.cells.nc; i++) for(let j=0;j<sim.cells.nr;j++)
       {
           if(this.grid[i][j].alive == 1)
           {
               num_alive++
               gsizes+=this.grid[i][j].genomesize
               fitnesses += this.grid[i][j].genome.fitness
               for(let p=0;p<sim.cells.grid[i][j].genome.chromosome.length;p++)
                   switch(sim.cells.grid[i][j].genome.chromosome[p].type)
                   {
                           case "G": hks++; break;
                           case "g": nes++; break;
                           case ".": non++; break;
                           case "T": tra++; break;
                   }
           }
       }
       this.plotArray(["Genome size","Essential","Non-essential","Non-coding","Transposons"], 
                        [gsizes/num_alive,hks/num_alive,nes/num_alive,non/num_alive,tra/num_alive],
                         ["black","blue","green","grey","red"],
                        "Avg genome size and composition")    
        this.plotArray(["Fitness"], 
                        [fitnesses/num_alive],
                         ["black"],
                        "Avg fitness")
    }

   

       
    sim.addButton("pause/continue",function() {sim.toggle_play()})              // Add a button that calls function "display" in "model"
    sim.addButton("well-mix",function() { sim.toggle_mix()})                    // Add a button that calls function "perfectMix" in "model.cheater"  
    sim.addButton("reset",function() { sim.cells.initialise()})                    // Add a button that calls function "perfectMix" in "model.cheater"  
    sim.addHTML("form_holder","<br>")
    sim.addSlider("mutationrate",0.0,0.01,0.0001)
  
    sim.start()
}

/**
 *  Gridmodel is the main (currently only) type of model in Cacatoo. Most of these models
 *  will look and feel like CAs, but GridModels can also contain ODEs with diffusion, making
 *  them more like PDEs. 
 */


class Genome
{
    // Genome constructor
    constructor()
    {
        this.uid = genomeIds.next()
        this.total_num_hk = init_es
        this.total_num_ne = init_ne  
    }

    initialise(init_hk,init_ne,init_nc,init_tr)
    {
        this.generation = 1
        this.chromosome = []
              
        for(let i=0;i<init_hk;i++) this.chromosome.push(new Gene("G",i))
        for(let i=0;i<init_ne;i++) this.chromosome.push(new Gene("g",i))
        for(let i=0;i<init_nc;i++) this.chromosome.push(new Gene(".",0))
        for(let i=0;i<init_tr;i++) this.chromosome.push(new Gene("T",0,0.85))
        shuffle(this.chromosome)
        this.calculate_fitness()
    }

    copy(mutate)
    {
        let child = new Genome()
        child.chromosome = []
        for(let i=0;i<this.chromosome.length;i++) child.chromosome.push(this.chromosome[i].copy())
        child.generation = this.generation+1
        if(mutate) child.mutate()        
        return child
    }
    
    calculate_fitness()
    {
        this.fitness = 1.0

        let hks =[], nes = []
        hks.length = this.total_num_hk
        nes.length = this.total_num_ne
        for(let i=0;i<this.chromosome.length;i++)
        {
            let gene = this.chromosome[i]
            switch(gene.type)
            {
                case "G":
                    hks[gene.func] = 1
                case "g":
                    nes[gene.func] = 1
            }
        }
        // console.log(nes)
        for(let i=0; i<nes.length; i++) if(nes[i]==1) this.fitness+=0.1
        let hks_present = 0
        for(let i=0; i<hks.length; i++)  hks_present += hks[i];         
        if(hks_present < this.total_num_hk) this.fitness = 0.0
    }

    

    mutate()
    {
        let mutation = false
        for(let i=0;i<this.chromosome.length;i++) 
        {
            // Mutations with the javascript "splice" function: splice(pos,num_remove,append_this)
            let randomnr = sim.rng.genrand_real1()
            if(randomnr<gene_deletion_rate)
            {
                this.chromosome.splice(i,1)                                                               // Single gene deletion (splice 1 off, starting from i, append nothing)
                mutation = true
            }
            else if(randomnr<gene_deletion_rate+gene_duplication_rate)
            {
                let newgene = this.chromosome[i].copy()
                this.chromosome.splice(i,0,newgene)                                            // Single gene duplication (splice 0 off, but append the current pos to the array)
                mutation = true
            } 
            else if(randomnr<gene_deletion_rate+gene_duplication_rate+gene_tandem_deletion) 
            {
                let size = sim.rng.genrand_real1()*this.chromosome.length/4
                this.chromosome.splice(i,size)                // Tandem deletion (splice up to a fourth of, plus one to ensure the last can be deleted)
                mutation = true
            }
            else if(randomnr <gene_deletion_rate+gene_duplication_rate+gene_tandem_deletion+gene_tandem_duplication) 
            {
                if(this.chromosome.length > 1000) break                
                let size = Math.floor(1+sim.rng.genrand_real1()*this.chromosome.length/4)
                if(size > this.chromosome.length) size = this.chromosome.length
                // console.log(`Tandem duplication happens at pos ${i} with size ${size}`)
                // console.log('before',this.chromosome)
                const strand = [...this.chromosome.slice(i,i+size)]
                // console.log(strand)
                this.chromosome.splice(i,0,...strand)
                // for(let p = 0; p < size; p++)
                // {
                //     this.chromosome.splice(i,0,...this.chromosome.slice(i,0,this.chromosome[p+i]))                                                              // Tandem duplication
                //     i++
                // }
                // console.log('after',this.chromosome)
                i+=size        
                mutation = true  
                // throw new Error("KLaar")      
            }
        }
        this.calculate_fitness()
    }
}

class Gene
{
    // Gene constructor
    constructor(type,func,transposition_rate)
    {
        this.uid = geneIds.next()                       // Just so it has a unique identifier, no biological function
        this.type = type                        // Here assigned a string to a gene, being either "essential", "non-essential", "non-coding", or "transposon"
        this.func = func                // A number indicating the function of that gene (e.g. 1 type of each function is necessary for absolutely essential, while non-essential yields incremental benefits)
        this.transposition_rate = transposition_rate || 0.0
    }

    copy()
    {
        return new Gene(this.type,this.func,this.transposition_rate)
    }
}


/**
 * Shuffles array in place.
 * @param {Array} a items An array containing the items.
 */
 function shuffle(a) {
    var j, x, i;
    for (i = a.length - 1; i > 0; i--) {
        j = Math.floor(Math.random() * (i + 1));
        x = a[i];
        a[i] = a[j];
        a[j] = x;
    }
    return a;
}

function* idGenerator() 
{
    let id = 1;
    while(true)
    {
        yield id
        id++
    }
}
const genomeIds = idGenerator()
const geneIds = idGenerator()
/*-------------------------End user-defined code ---------------------*/

</script>

<body onload="cacatoo()">        
    <div class="header" id="header"><h2>ModelJS - </h2></div>
    <div class="content" id="canvas_holder"></div>
    <div class="content" id="form_holder"></div>    
    <div class="content" id="graph_holder"> </div>
    <div class="footer" id="footer"></div>
</body>
</html>