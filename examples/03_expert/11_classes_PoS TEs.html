<html>
<script src="../../dist/cacatoo.js"></script>                 <!-- Include cacatoo library (compiled with rollup) -->
<script src="../../lib/all.js"></script>                      <!-- Include other libraries (concattenated in 1 file) -->
<script src="../../lib/odex.js"></script>                      <!-- Include other libraries (concattenated in 1 file) -->
<script src="./PoS_classes.js"></script>
<link rel="stylesheet" href="../../style/cacatoo.css">        <!-- Set style sheet -->

<script>
/*-----------------------Start user-defined code ---------------------*/

let sim;

// PARAMETERS FOR FITNESS DEFINITION
let init_es = 10                   // es = essential     --- if even a single one is missing = 0.0 fitness
let init_ne = 10                   // ne = non-essential --- for each non-essential genes gain "non_essential_gene_boon" fitness
let non_essential_gene_boon = 0.1

// PARAMETERS FOR ECOLOGY
let death_rate = 0.02

// PARAMETERS FOR EVOLUTION
let gene_inactivation_rate = 0.001
let gene_deletion_rate = 0.001
let gene_duplication_rate = 0.001
let gene_tandem_deletion = 0.001
let gene_tandem_duplication = 0.001

// PARAMETERS FOR EDNA POOL
degr_rate_edna = 0.02
diff_rate_edna = 0.01


function cacatoo()
{

    let config = {
            title: "Coevolution of TEs and their host",
            description: "",
            maxtime: 100000,
            fastmode: false,             // If possible, fast-mode will update the sim with more than 60 FPS. 
                                        // Note: fastmode is only useful/recommended if the sim can readily run 
                                        // at 60FPS without fast-mode, and may actually reduce the reported FPS
                                        // Nevertheless, the final state of the grid is reaches sooner in real time. 
            ncol : 100,            
            nrow : 100,		            // dimensions of the grid to build
            wrap : [true, true],       // Wrap boundary [COLS, ROWS]   
            scale : 3,				    // scale of the grid (nxn pixels per grid cell)
            graph_interval: 10,
            graph_update: 20,
            statecolours: {alive:{1:'blue'}}   // The background state '0' is never drawn
    }

    sim = new Simulation(config)

    sim.makeGridmodel("cells");
    
    sim.createDisplay("cells","genomesize")   
    sim.cells.colourViridis("genomesize", 100)

    sim.createDisplay("cells","T_in_eDNA") 
    sim.cells.colourViridis("T_in_eDNA", 100)   
    

    sim.cells.initialise = function()
    {
        sim.initialGrid(sim.cells,"alive",0,1.0)
        sim.initialGrid(sim.cells,"genomesize",undefined,1.0)

        for(let i=0; i<sim.cells.nc; i++) for(let j=0;j<sim.cells.nr;j++)
        {
            this.grid[i][j].eDNA = []        // Initialise empty eDNA pool
            let size = 5
            if((Math.pow((i-sim.cells.nc/2),2) + Math.pow((j-sim.cells.nr/2),2) ) < size)
            { 
                sim.cells.grid[i][j].alive = 1
                sim.cells.grid[i][j].genome = new Genome()
                sim.cells.grid[i][j].genome.initialise(init_es,init_ne,0,10)
                sim.cells.grid[i][j].genomesize = Math.min(100,sim.cells.grid[i][j].genome.chromosome.length)             // A copy of the genome size is also stored within the grid point itself, so we can visualise it on the grid (capped at 100)
                sim.cells.grid[i][j].fitness = sim.cells.grid[i][j].genome.fitness                          // A copy of the genomes' fitness is stored within the grid point itself, so we can use it for the "rouletteWheel" function
            }
            else if((Math.pow((i-sim.cells.nc/2),2) + Math.pow((j-sim.cells.nr/2),2) ) < size*5)
            {
                sim.cells.grid[i][j].alive = 1
                sim.cells.grid[i][j].genome = new Genome()
                sim.cells.grid[i][j].genome.initialise(init_es,init_ne,0,0)
                sim.cells.grid[i][j].genomesize = Math.min(100,sim.cells.grid[i][j].genome.chromosome.length)             // A copy of the genome size is also stored within the grid point itself, so we can visualise it on the grid (capped at 100)
                sim.cells.grid[i][j].fitness = sim.cells.grid[i][j].genome.fitness                          // A copy of the genomes' fitness is stored within the grid point itself, so we can use it for the "rouletteWheel" function
            }
        }
    }

    sim.cells.initialise()  // Initialise for the first time (otherwise used for "RESET" button)
    
        
    let birth_rate = 0.85
                
    sim.cells.nextState = function(i,j)       // Define the next-state function. This example is stochastic growth in a petri dish
    {           
        if(this.grid[i][j].alive == 0)
        {                   
            let neighbours = this.getMoore8(this,i,j,1,'alive')
            
            if(neighbours.length > 0) 
            {   
                let winner = this.rouletteWheel(neighbours,'fitness',10.5)
                if(winner!=undefined)
                    this.reproduce(i,j,winner)            
            }
        } 
        else if(this.rng.genrand_real1() < death_rate)
            this.death_and_lysis(i,j)      
        else
            this.TEdynamicsI(i,j)
            
        // EDNA DYNAMICS
        if(this.grid[i][j].eDNA.length>0)
        {

            for(let k=0;k<this.grid[i][j].eDNA.length;k++)
                if(this.rng.genrand_real1() < degr_rate_edna)
                    this.grid[i][j].eDNA.splice(k,1)

            this.grid[i][j].T_in_eDNA = Math.min(100,this.grid[i][j].eDNA.length)   // Track number of TEs for visualisation purposes
            
        }
        else
            this.grid[i][j].T_in_eDNA = undefined
    }

    // This function is asynchronously applied to the entire grid every time step. It uses a single random number to determine both IF a DNA fragment will move,
    // as well as WHERE it moves. 
    sim.cells.diffuse_eDNA = function(i,j)
    {        
        moveDNA = function(k,direction)
        {
            let coords = sim.cells.moore[direction]
            let target = sim.cells.getGridpoint(coords[0]+i,coords[1]+j)
            target.eDNA.push(sim.cells.grid[i][j].eDNA[k])
            sim.cells.grid[i][j].eDNA.splice(k,1)
        }

        for(let k=0;k<sim.cells.grid[i][j].eDNA.length;k++)
        {
            let randomnr = sim.cells.rng.genrand_real1()               
            if(randomnr < degr_rate_edna/8) moveDNA(k,1)         
            else if(randomnr < 2*degr_rate_edna/8) moveDNA(k,2)
            else if(randomnr < 3*degr_rate_edna/8) moveDNA(k,3)
            else if(randomnr < 4*degr_rate_edna/8) moveDNA(k,4)
            else if(randomnr < 5*degr_rate_edna/8) moveDNA(k,5)
            else if(randomnr < 6*degr_rate_edna/8) moveDNA(k,6)
            else if(randomnr < 7*degr_rate_edna/8) moveDNA(k,7)
            else if(randomnr < 8*degr_rate_edna/8) moveDNA(k,8)            
        }
    }

    

    // A custom function for copying a cell into a gp at position i,j ("reproduction")
    sim.cells.reproduce = function(i,j,winner)
    {
        this.grid[i][j].alive = winner.alive
        this.grid[i][j].genome = winner.genome.copy(mutate=true)
        this.grid[i][j].genomesize = Math.min(100,this.grid[i][j].genome.chromosome.length)
        this.grid[i][j].fitness = this.grid[i][j].genome.fitness
    }

    // A custom function for killing a gp at position i,j
    sim.cells.death_and_lysis = function(i,j)
    {
        this.grid[i][j].alive = 0
        this.grid[i][j].genomesize = undefined
        
        for(let p=0;p<this.grid[i][j].genome.chromosome.length;p++)
        {
            if(this.grid[i][j].genome.chromosome[p].type == "T")
                this.grid[i][j].eDNA.push(this.grid[i][j].genome.chromosome[p])
        }
    }

    // A custom function for TE dynamics during the lifetime of a cell
    sim.cells.TEdynamicsI = function(i,j)
    {
        jumping = []
        for(let p=0;p<this.grid[i][j].genome.chromosome.length;p++)
        {
            if(this.grid[i][j].genome.chromosome[p].type == "T")
            {
                if(this.rng.genrand_real1() < 1.01*this.grid[i][j].genome.chromosome[p].transposition_rate)
                    jumping.push(this.grid[i][j].genome.chromosome[p])
            }
        }
        for(let p=0;p<jumping.length;p++)
        {
            // console.log("Now actually do the jump")
        }
        // console.log(jumping)
    }

    
    sim.cells.update = function()
    {
        this.synchronous()         // Applied as many times as it can in 1/60th of a second
        this.apply_async(this.diffuse_eDNA)
        this.plotPopsizes('alive',[1]) 

       let num_alive = 0, gsizes=0, hks = 0, nes = 0, non = 0, tra = 0, fitnesses = 0
       for(let i=0; i<sim.cells.nc; i++) for(let j=0;j<sim.cells.nr;j++)
       {
           if(this.grid[i][j].alive == 1)
           {
               num_alive++
               gsizes+=this.grid[i][j].genomesize
               fitnesses += this.grid[i][j].genome.fitness
               for(let p=0;p<sim.cells.grid[i][j].genome.chromosome.length;p++)
                   switch(sim.cells.grid[i][j].genome.chromosome[p].type)
                   {
                           case "G": hks++; break;
                           case "g": nes++; break;
                           case ".": non++; break;
                           case "T": tra++; break;
                   }
           }
       }
       this.plotArray(["Genome size","Essential","Non-essential","Non-coding","Transposons"], 
                        [gsizes/num_alive,hks/num_alive,nes/num_alive,non/num_alive,tra/num_alive],
                         ["black","blue","green","grey","red"],
                        "Avg genome size and composition")    
        this.plotArray(["Fitness"], 
                        [fitnesses/num_alive],
                         ["black"],
                        "Avg fitness")
    }

   

       
    sim.addButton("pause/continue",function() {sim.toggle_play()})              // Add a button that calls function "display" in "model"
    sim.addButton("well-mix",function() { sim.toggle_mix()})                    // Add a button that calls function "perfectMix" in "model.cheater"  
    sim.addButton("reset",function() { sim.cells.initialise()})                    // Add a button that calls function "perfectMix" in "model.cheater"  
    sim.addHTML("form_holder","<br>")
    sim.addSlider("mutationrate",0.0,0.01,0.0001)
  
    sim.start()
}


/*-------------------------End user-defined code ---------------------*/

</script>

<body onload="cacatoo()">        
    <div class="header" id="header"><h2>ModelJS - </h2></div>
    <div class="content" id="canvas_holder"></div>
    <div class="content" id="form_holder"></div>    
    <div class="content" id="graph_holder"> </div>
    <div class="footer" id="footer"></div>
</body>
</html>